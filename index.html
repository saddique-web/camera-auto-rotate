<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>Camera Capture — Keep Landscape Photos Landscape</title>
  <style>
    body { font-family: system-ui, -apple-system, Roboto, Arial; padding: 1rem; }
    .controls { margin-bottom: 1rem; display:flex; gap:0.5rem; align-items:center; flex-wrap:wrap; }
    video, canvas { border: 1px solid #ccc; max-width:100%; height:auto; display:block; }
    .note { color:#555; font-size:0.9rem; margin-top:0.5rem; }
    button { padding:.4rem .8rem; }
  </style>
</head>
<body>
<h1>Camera Capture — Orientation Friendly</h1>

<div class="controls">
  <!-- Use capture input (opens device camera on mobile) -->
  <input id="file" type="file" accept="image/*" capture="environment">
  <button id="startCam">Start Camera</button>
  <button id="takePhoto" disabled>Take Photo (from camera)</button>
  <button id="download" disabled>Download corrected image</button>
</div>

<video id="video" playsinline autoplay muted style="display:none"></video>
<canvas id="canvas"></canvas>

<div class="note">
  - You can take a photo with your device camera (file input) or use the live camera (Start Camera → Take Photo). Landscape photos will be shown correctly.
</div>

<!-- exif-js to read orientation from image files (JPEG from file input) -->
<script src="https://cdn.jsdelivr.net/npm/exif-js"></script>
<script>
  // Elements
  const input = document.getElementById('file');
  const video = document.getElementById('video');
  const canvas = document.getElementById('canvas');
  const ctx = canvas.getContext('2d');
  const startCamBtn = document.getElementById('startCam');
  const takePhotoBtn = document.getElementById('takePhoto');
  const downloadBtn = document.getElementById('download');

  let stream = null;

  // Helper: get current display rotation in degrees (0,90,180,270)
  function getDisplayRotation() {
    // Prefer Screen Orientation API
    if (screen && screen.orientation && typeof screen.orientation.angle === 'number') {
      return screen.orientation.angle;
    }
    // Fallback to window.orientation (some browsers)
    if (typeof window.orientation === 'number') {
      return (window.orientation + 360) % 360;
    }
    // Default 0
    return 0;
  }

  // Draw image to canvas honoring EXIF orientation (for file input)
  function drawImageWithExif(img, orientation) {
    const iw = img.naturalWidth;
    const ih = img.naturalHeight;
    const rotated = [5,6,7,8].includes(orientation);

    canvas.width = rotated ? ih : iw;
    canvas.height = rotated ? iw : ih;

    ctx.save();

    switch (orientation) {
      case 2: // flip horizontal
        ctx.translate(canvas.width, 0);
        ctx.scale(-1, 1);
        ctx.drawImage(img, 0, 0, iw, ih);
        break;
      case 3: // rotate 180
        ctx.translate(canvas.width, canvas.height);
        ctx.rotate(Math.PI);
        ctx.drawImage(img, 0, 0, iw, ih);
        break;
      case 4: // flip vertical
        ctx.translate(0, canvas.height);
        ctx.scale(1, -1);
        ctx.drawImage(img, 0, 0, iw, ih);
        break;
      case 5: // transpose
        ctx.rotate(0.5 * Math.PI);
        ctx.scale(1, -1);
        ctx.drawImage(img, 0, 0, iw, ih);
        break;
      case 6: // rotate 90
        ctx.translate(canvas.width, 0);
        ctx.rotate(0.5 * Math.PI);
        ctx.drawImage(img, 0, 0, iw, ih);
        break;
      case 7: // transverse
        ctx.translate(canvas.width, 0);
        ctx.rotate(0.5 * Math.PI);
        ctx.scale(-1, 1);
        ctx.drawImage(img, 0, 0, iw, ih);
        break;
      case 8: // rotate 270
        ctx.translate(0, canvas.height);
        ctx.rotate(-0.5 * Math.PI);
        ctx.drawImage(img, 0, 0, iw, ih);
        break;
      default: // 1 - normal
        ctx.drawImage(img, 0, 0, iw, ih);
    }

    ctx.restore();
  }

  // Handle file input (photo taken by camera app or selected)
  input.addEventListener('change', (ev) => {
    downloadBtn.disabled = true;
    const file = ev.target.files && ev.target.files[0];
    if (!file) return;
    if (!file.type.startsWith('image/')) {
      alert('Please select an image file.');
      return;
    }

    // Read ArrayBuffer for EXIF
    const frExif = new FileReader();
    frExif.onload = function(e) {
      try {
        const arrayBuffer = e.target.result;
        const exif = EXIF.readFromBinaryFile(arrayBuffer) || {};
        const orientation = exif.Orientation || 1;

        // Read DataURL to load image
        const frData = new FileReader();
        frData.onload = function(e2) {
          const img = new Image();
          img.onload = function() {
            drawImageWithExif(img, orientation);
            downloadBtn.disabled = false;
          };
          img.src = e2.target.result;
        };
        frData.readAsDataURL(file);
      } catch (err) {
        // fallback: load and draw normally
        const frData = new FileReader();
        frData.onload = function(e2) {
          const img = new Image();
          img.onload = function() {
            drawImageWithExif(img, 1);
            downloadBtn.disabled = false;
          };
          img.src = e2.target.result;
        };
        frData.readAsDataURL(file);
      }
    };
    frExif.readAsArrayBuffer(file);
  });

  // Start live camera (getUserMedia)
  startCamBtn.addEventListener('click', async () => {
    downloadBtn.disabled = true;
    try {
      // Prefer environment-facing camera on mobile
      stream = await navigator.mediaDevices.getUserMedia({
        video: { facingMode: 'environment' },
        audio: false
      });
      video.srcObject = stream;
      video.style.display = 'block';
      takePhotoBtn.disabled = false;
      // Resize canvas to video size once metadata is available
      video.addEventListener('loadedmetadata', () => {
        // keep canvas size in sync but we'll set exact size at capture
        canvas.width = video.videoWidth;
        canvas.height = video.videoHeight;
      }, { once: true });
    } catch (err) {
      alert('Could not access camera: ' + err.message);
    }
  });

  // Take photo from live video stream and rotate according to device orientation
  takePhotoBtn.addEventListener('click', () => {
    if (!video || !video.videoWidth) return;

    // video natural size
    const vw = video.videoWidth;
    const vh = video.videoHeight;
    const rotation = getDisplayRotation(); // 0,90,180,270

    // Determine whether rotation swaps width/height
    const rotated = (rotation === 90 || rotation === 270);

    canvas.width = rotated ? vh : vw;
    canvas.height = rotated ? vw : vh;

    ctx.save();

    // Translate/rotate such that the captured image respects the current display rotation.
    // We assume the camera's video is in the natural sensor orientation and we rotate the canvas for display.
    switch (rotation) {
      case 90:
        ctx.translate(canvas.width, 0);
        ctx.rotate(0.5 * Math.PI);
        ctx.drawImage(video, 0, 0, vw, vh);
        break;
      case 180:
        ctx.translate(canvas.width, canvas.height);
        ctx.rotate(Math.PI);
        ctx.drawImage(video, 0, 0, vw, vh);
        break;
      case 270:
        ctx.translate(0, canvas.height);
        ctx.rotate(-0.5 * Math.PI);
        ctx.drawImage(video, 0, 0, vw, vh);
        break;
      default: // 0
        ctx.drawImage(video, 0, 0, vw, vh);
    }

    ctx.restore();
    downloadBtn.disabled = false;
  });

  // Download corrected image
  downloadBtn.addEventListener('click', () => {
    canvas.toBlob((blob) => {
      if (!blob) return;
      const a = document.createElement('a');
      a.href = URL.createObjectURL(blob);
      a.download = 'photo-corrected.jpg';
      document.body.appendChild(a);
      a.click();
      a.remove();
    }, 'image/jpeg', 0.92);
  });

  // Clean up stream on unload
  window.addEventListener('beforeunload', () => {
    if (stream) {
      stream.getTracks().forEach(t => t.stop());
    }
  });
</script>
</body>
</html>
